<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metriffic - About</title>
    <link href="http://fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,400italic,500,500italic,700,700italic,900italic,900" rel="stylesheet">
    <style>
        html, body, html * {
            line-height: normal;
        }

        body {
            margin: 0;
        }

        .about-container {
            width: 80vw;
        }

        .about-container h4 {
            margin-top: 2rem;
        }

        .about-container h6 {
            font-size: 1.2rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .about-container p {
            text-align: justify;
        }

        .toc {
            font-size: 14px;
            width: 250px;
            background-color: #ffffff;
            padding: 20px;
            height: 100vh;
            overflow-y: auto;
            position: fixed;
            left: 0;
            top: 0;
            border-right: 1px solid #ddd;
        }

        .toc-title {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .nav-links {
            list-style: none;
            padding: 0;
        }

        .nav-links li {
            margin: 12px 0 5px 0px;
        }

        .nav-links a {
            color: #333;
            text-decoration: none;
        }

        .nav-links a:hover {
            color: #072341;
        }

        .sub-links {
            list-style: none;
            padding-left: 20px;
        }

        .sub-links li {
            margin-top: 0px;
            margin-bottom: 2px;
        }

        .main-content {
            margin-left: 270px;
            padding: 20px;
            width: 700px;
        }

        .image-gallery {
            margin-bottom: 15px;
        }

        .thumbnail-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .thumbnail {
            width: 150px;
            object-fit: cover;
            border-radius: 0.25rem;
        }

        .code-section {
            display: block;
            padding: 0.2rem 1rem;
            margin: 0.3rem 0 .3rem 0;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            color: #374151;
            font-size: 0.875rem;
            width: -webkit-fill-available;
        }

        .code-section h5 {
            margin: 0.5rem 0;
            color: #1f2937;
        }

        .code-section pre {
            font-size: 11px;
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.25rem;
            overflow-x: auto;
            white-space: pre-wrap;
            margin: 0.5rem 0;
        }

        .code-section div {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 11px;
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.25rem;
            margin: 0.5rem 0;
        }

        .video-screencast {
            width: 650px;
            border-radius: 5px;
            border: 1px solid #bbbbbb;
            display: block;
            margin: 5px auto 5px auto;
        }

        .subsection-break {
            height: 20px;
        }

        .command-help {
            font-size: 11px;
            width: 800px;
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.25rem;
            overflow-x: auto;
        }

        .stripped-p {
            margin-bottom: 0px;
        }

        .bold-line {
            display: block;
            padding: 0px 30px 0px 30px;
        }

        .url-line {
            display: block;
            padding: 0px 30px 0px 30px;
        }

        .tldr {
            border-left: 4px solid #0ea5e9;
            background: #f8fafc;
            padding: .75rem 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .clickable-item {
            font-weight: 600;
            color: #1f2937;
            cursor: pointer;
            padding: 0.5rem 0;
        }
    </style>
</head>
<body>
    <div class="about-container">
        <aside class="toc">
            <h4 class="toc-title">Metriffic</h4>
            <ul class="nav-links">
                <li><a href="#section_tldr">TL;DR</a></li>
                <li><a href="#section_introduction">Introduction</a></li>
                <li><a href="#section_supported_functionality">Supported Functionality</a></li>
                <li><a href="#section_under_the_hood">Under the Hood</a></li>
                <ul class="sub-links">
                    <li><a href="#subsection_system_design">System Design</a></li>
                    <li><a href="#subsection_source_code">Source Code</a></li>
                    <li><a href="#subsection_build_cli">Building the CLI tool</a></li>
                </ul>
                <li><a href="#section_registration">User Registration</a></li>
                <li><a href="#section_cli_commands">CLI Commands</a></li>
                <ul class="sub-links">
                    <li><a href="#subsection_show_commands"><b><u>show</u></b></a></li>
                    <li><a href="#subsection_interactive_commands"><b><u>interactive</u></b></a></li>
                    <li><a href="#subsection_batch_commands"><b><u>batch</u></b></a></li>
                    <li><a href="#subsection_workspace_commands"><b><u>workspace</u></b></a></li>
                </ul>
                <li><a href="#section_knownissues">Known Issues and Limitations</a></li>
                <li><a href="#section_nextsteps">Planned Features</a></li>
            </ul>
        </aside>

        <main class="main-content">
            <section class="content">
                <!-- TL;DR Section -->
                <h4 id="section_tldr">TL;DR</h4>
                <div class="tldr">
                    <ul style="margin-bottom:0">
                        <li><b>What:</b> SGE-style scheduler + Docker on SoM boards for reproducible tests/benchmarks and interactive SSH sessions (remote dev).</li>
                        <li><b>Who:</b> Robotics/embedded engineers comparing SoMs and tuning models/pipelines.</li>
                        <li><b>Why:</b> Reproducible runs, easy access to boards, comparable reports.</li>
                        <li><b>Status:</b> Side project. Beta ready. Access on request.</li>
                    </ul>
                </div>

                <h4 id="section_introduction">Introduction</h4>
                <h6 id="subsection_about_the_service">About the Service</h6>
                <p>
                    Metriffic automates running and managing workloads on System on Module (SoM) boards used in robotics,
                    smart devices and similar projects. Taking inspiration from Sun Grid Engine (SGE), it applies
                    SGE-style scheduling and resource management, tailored for single-board SoM environments.
                </p>
                <p>
                    The service simplifies platform access for both testing and performance analysis. You can validate your 
                    applications and ML models using prerecorded datasets, run benchmarks and conduct optimization experiments. 
                    It helps developers tune applications and find the right trade-off between computational performance, power
                    consumption and cost. 
                </p>
                <p>
                    I started this as a side project during COVID, so the currently supported platforms are a bit dated:
                </p>
                <ul style="list-style-type:circle; margin-top: -8px">
                    <li>Jetson Nano</li>
                    <li>Google Coral Dev Board</li>
                    <li>Raspberry Pi 4</li>
                    <li>Raspberry Pi 3</li>
                </ul>
                <p>
                    Adding support for new platforms and extending the grids is straightforward — happy to do so if there's interest. <br/> 
                    Everything, including this website, runs off a small server in my garage (photos below). 
                </p>
                
                <div class="image-gallery">
                    <div class="thumbnail-container">
                        <img src="/server/mf.1.jpg" alt="server #1" class="thumbnail" />
                        <img src="/server/mf.2.jpg" alt="server #2" class="thumbnail" />
                        <img src="/server/mf.3.jpg" alt="server #3" class="thumbnail" />
                    </div>
                </div>

                <p>
                    That works fine for now, but if I add too many boards, bandwidth might not keep up and I may move it to a colocation center.<br/>
                    Most core features are in place and reasonably well tested. Want to try it? Drop 
                    me a message through the main page — I'd love to share access and hear your thoughts.
                </p>

                <div class="subsection-break"></div>

                <!-- Supported Functionality promoted to top-level -->
                <h4 id="section_supported_functionality">Supported Functionality</h4>
                <p>
                    The service supports three main operation types:
                </p>
                <ul style="list-style-type:circle">
                    <li><b>Query</b>: display available resources (e.g., platforms, Docker images) and query sessions or jobs.</li>
                    <li><b>Session</b>: start batch or interactive sessions, stop active sessions and check session status.</li>
                    <li><b>Workspace</b>: synchronize your local workspace with the remote one and manage the local workspace path (show or set).</li>
                </ul>
                <p style="margin-bottom:10px">
                    Core principles:
                </p>              
                <ul style="list-style-type:circle">
                    <li><b>Containerization</b>: all processing (batch tasks or live SSH sessions) runs in Docker containers for a controlled, reproducible environment.</li>
                    <li><b>Single-container restriction</b>: each board runs only one container at a time for full resource access and clean comparisons.</li>
                    <li><b>Volume mounts</b>:
                        <ul style="list-style-type:square">
                            <li><b>/workspace</b>: private read/write userspace for scripts, models and datasets.</li>
                            <li><b>/public</b>: public, read-only space with shared models, datasets, evaluation scripts, etc.</li>
                        </ul>
                    </li>    
                </ul>

                <div class="subsection-break"></div>

                <h4 id="section_under_the_hood">Under the Hood</h4>
                <h6 id="subsection_system_design">System Design</h6>
                <p>
                    Here's a diagram showing the different parts of the system and how they interact.
                </p>
                <img style="display:block; margin:0px auto 20px auto; width:650px" src="system_design.svg" alt="System design diagram" />
                <p class="stripped-p">On the left are the two user interfaces:</p>
                <ul>
                    <li>The CLI tool handles most interactions with the service: submit/cancel jobs, check status, exchange data.</li>
                    <li>The web service currently provides profile configuration.</li>
                </ul>
                <p class="stripped-p">On the right are the Metriffic services/components:</p>
                <ul>
                    <li>Scheduler &amp; job queue</li>
                    <li>Grid service (board allocator &amp; container runtime)</li>
                    <li>Bastion (SSH tunneling)</li>
                    <li>Workspace sync (rsync orchestration)</li>
                    <li>Web UI</li>
                </ul>

                <div class="subsection-break"></div>

                <h6 id="subsection_source_code">Source Code</h6>
                <p class="stripped-p">
                    Metriffic is open-source. <br/>
                    The cloud-side code is implemented in JS/Node and is available in these repositories:
                    <a class="url-line" href="https://github.com/metriffic/metriffic-backend">https://github.com/metriffic/metriffic-backend</a>
                    <a class="url-line" href="https://github.com/metriffic/metriffic-grid-service">https://github.com/metriffic/metriffic-grid-service</a>
                    <a class="url-line" href="https://github.com/metriffic/metriffic-workspaces">https://github.com/metriffic/metriffic-workspaces</a>
                    <a class="url-line" href="https://github.com/metriffic/metriffic-web">https://github.com/metriffic/metriffic-web</a>
                    This repository contains some configuration scripts and Docker files that can help with server setup:
                    <a class="url-line" href="https://github.com/metriffic/metriffic-cm.git">https://github.com/metriffic/metriffic-cm.git</a>
                    It's partially automated and still requires several manual steps. Feel free to contact me if you're interested—happy to help.
                </p>
                <p style="margin-top:10px">The command-line tool is in C++:
                    <a class="url-line" href="https://github.com/metriffic/metriffic-cli.git">https://github.com/metriffic/metriffic-cli.git</a>
                    The section below describes how to build it.
                </p>

                <div class="subsection-break"></div>

                <h6 id="subsection_build_cli">Building the CLI Tool</h6>
                <p class="stripped-p">
                    The command-line tool (metriffic) is a C++ application that requires compilation. To build it
                    for Ubuntu, follow these steps.
                </p>
                <div class="code-section">
                    <div class="clickable-item">build instructions</div>
                    <pre># install the required packages (ubuntu 22.04+)
sudo apt update
sudo apt install build-essential vim git cmake libboost-system-dev libboost-chrono-dev \
            libboost-thread-dev libboost-filesystem-dev libssh2-1-dev openssl
# clone the repo
git clone https://github.com/metriffic/metriffic-cli.git
# and build it...
cd metriffic-cli
git submodule update --init --recursive
mkdir build; cd build
cmake ..
make</pre>
                </div>
                <p>
                    (planning to share the Homebrew recipe soon...)
                </p>

                <div class="subsection-break"></div>

                <h4 id="section_registration">User Registration</h4>
                <p>
                    Registration is a two-step process. First, an account is created on the server side by service admins.
                    <br/>
                    In the second step, the user generates <b>two SSH keypairs</b> and registers them in their profile:
                </p>
                <ul style="list-style-type:circle">
                    <li><b>Bastion key</b> — authenticates the SSH tunnel via <code>metriffic.com:2222</code>.</li>
                    <li><b>Container key</b> — injected into the container's <code>/root/.ssh/authorized_keys</code> to access a running session.</li>
                </ul>
                <p>
                    The service avoids passwords. Logging in to the web UI works through OTP emailed to the user.
                    SSH-based services (workspace rsync and container access) use your registered keys.
                </p>
                <p class="stripped-p">This video demonstrates how to do the second step.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.adding_keys.mp4" type="video/mp4" />
                </video>

                <div class="subsection-break"></div>

                <h4 id="section_cli_commands">CLI Commands</h4>
                <h6 id="subsection_show_commands"><b><u>show</u></b></h6>
                <p class="stripped-p">Command options:</p>
                <pre class="command-help">show &lt;items&gt;: mandatory argument, the type of data to show. Can be either 'platforms',
        'sessions' or 'docker-images'.
   -p|--platform &lt;platform name&gt;: platform selector, can be used when querying docker-images
   -f|--filter &lt;status&gt;: used for sessions, format: {state:SUBMITTED|RUNNING|CANCELED|COMPLETED}.</pre>
                <p class="stripped-p" style="margin-top:15px">Here's how it works.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.show.mp4" type="video/mp4" />
                </video>

                <div class="subsection-break"></div>

                <h6 id="subsection_interactive_commands"><b><u>interactive</u></b></h6>
                <p class="stripped-p">Command options:</p>
                <pre class="command-help">interactive &lt;command&gt;: mandatory argument, session request to execute. Can be either
        'start', 'stop', 'join', 'status' or 'save'.
   -p|--platform &lt;platform name&gt;: name of the platform to start session on.
   -d|--docker-image &lt;docker image&gt;: docker image to instantiate on the target board.
   -c|--comment &lt;text&gt;: description of the requested operation.
   -n|--name &lt;name of the session&gt;: name of the session to perform operation on.</pre>
                <p class="stripped-p" style="margin-top:15px">This video demonstrates how this command can be used to start an interactive session and access the allocated machine.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.interactive_start.mp4" type="video/mp4" />
                </video>

                <div class="code-section">
                    <div class="clickable-item">what's going on here?</div>
                    <div>1. The user begins by displaying the help menu for the interactive command.
2. Initiates a session on an RPi4 machine using the standard Docker image 'rpi4-basic'.
   This command performs the following actions:
     - reserves a board of the specified type.
     - launches a Docker container on the reserved board, injects the user's public
       key into the container's '/root/.ssh/authorized_keys' file and starts an SSH
       server.
     - locates an available port on the user's machine and establishes an SSH tunnel
       through 'metriffic.com:2222' using it as a bastion, authenticated by the
       registered bastion public key.
     - outputs the SSH command needed to connect to the running Docker container via
       the Metriffic bastion.
3. Opens a new terminal tab and connects to the container via SSH.
4. Executes a few binaries to display platform information.
5. Following the same steps, the user starts another interactive session, this time
   on a Jetson Nano board.
6. Finally, the user runs the 'show sessions' command to display the status of both
   active sessions.</div>
                </div>

                <p class="stripped-p" style="margin-top:15px">This one shows how the Docker container can be modified, then committed and saved/pushed as a new image.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.interactive_save.mp4" type="video/mp4" />
                </video>

                <div class="code-section">
                    <div class="clickable-item">what's going on here?</div>
                    <div>1. The user runs 'show sessions' to display the active RPi4 session, then
   switches to the terminal tab where they have an SSH connection to that container.
2. Confirms that vim is not installed inside the container and proceeds to install it.
3. Returning to the CLI tool, the user runs 'interactive save' and names the new Docker
   image rpi4-basic-vim.
4. Once the operation is complete, the user calls 'show docker-images' to verify that the
   newly created image is listed and available.</div>
                </div>

                <p class="stripped-p" style="margin-top:15px">And this one shows how to re-establish a tunnel/connection to a container of an active interactive session.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.interactive_join.mp4" type="video/mp4" />
                </video>

                <div class="code-section">
                    <div class="clickable-item">what's going on here?</div>
                    <div>1. The user launches the CLI tool and logs in.
2. The user then runs 'show sessions' to display information about the two running
   interactive sessions: one on an RPi4 and another on a Jetson Nano.
3. Calls 'interactive join' to open a tunnel to the Docker container on the RPi4 board,
   then opens a new terminal tab and connects via SSH.
   The same steps are repeated for the Jetson Nano session.
4. Finally, the user stops both sessions, showing that the connections have been
   terminated and confirms by running 'show sessions' again to verify both sessions
   are closed.</div>
                </div>

                <div class="subsection-break"></div>

                <h6 id="subsection_batch_commands"><b><u>batch</u></b></h6>
                <p class="stripped-p">Command options:</p>
                <pre class="command-help">batch &lt;command&gt;: mandatory argument, session request to execute. Can be either
        'start', 'stop' or 'status'.
   -p|--platform &lt;platform name&gt;: name of the platform to start session on.
   -d|--docker-image &lt;docker image&gt;: docker image to instantiate on the target board.
   -r|--run-script &lt;script/binary&gt;: the script or binary command to execute,
        mandatory for batch mode.
   -s|--dataset-split &lt;n=1&gt;: split the dataset into this many chunks, one chunk per job.
   -j|--jobs &lt;n=1&gt;: maximum number of simultaneous jobs.
   -n|--name &lt;name of the session&gt;: name of the session to perform operation on.</pre>
                <p class="stripped-p">Demonstration of batch commands.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.batch.mp4" type="video/mp4" />
                </video>

                <div class="code-section">
                    <div class="clickable-item">what's going on here?</div>
                    <div>1. The user logs into the system and prints the workspace path.
2. Switches to the workspace, showing the shell script (to be passed to the command)
   and the Python script (which runs the batch job). The shell script demonstrates
   the input arguments provided by the system and the Python script shows how those
   arguments are used.
3. Calls 'workspace sync up' to upload the scripts to the system workspace.
   Note: 'workspace' command is covered in section 4.4.
4. Displays the help information for the batch command, then runs the command.
   Batch jobs are used for running parallel jobs on the grid. This is done by
   splitting the input dataset into chunks and feeding each chunk to a separate
   job. The command has two important arguments that control execution:
      -d|--dataset-split: specifies how many chunks the dataset should be split into
      -j|--max-jobs: specifies the max number of containers that can be run on the
                     grid simultaneously processing those chunks. This is the
                     max cap; the actual number of parallel jobs depends
                     on priority and grid utilization.
   When called, the command creates all these jobs and submits them to the scheduler.
   The session is complete when all jobs are done, or when it's canceled (by calling
   'batch stop' command)
5. The user monitors the session status until it is marked COMPLETED.
6. Finally, calls 'workspace sync down' to download the batch run artifacts into the
   local workspace. Then lists the downloaded session folder and shows the contents of
   output files.</div>
                </div>

                <p class="stripped-p">These are the scripts used in the demo:</p>
                <div class="code-section">
                    <div class="clickable-item">batch shell script</div>
                    <pre>#!/bin/bash
 session_dir="/workspace/session.$1"
 mkdir -p "$session_dir"
 python3 /workspace/run_imgnetdet.py --output-dir $session_dir --dataset-chunk $2 >& $session_dir/batch.$2.out</pre>
                </div>

                <div class="code-section">
                    <div class="clickable-item">inference py script</div>
                    <pre>import os
import time
import cv2
import json
import argparse
import numpy as np
from collections import defaultdict
from pycocotools.coco import COCO
from pycocotools.cocoeval import COCOeval
import tensorflow as tf

# Paths
MODEL_PATH = "/public/MobileNetSSD/detect.tflite"
COCO_ANNOTATIONS_PATH = "/public/instances_val2017.json"
IMAGES_DIR = "/public/val2017"

# Parameters
IMAGE_SIZE = (300, 300)  # Input size for MobileNet SSD
IOU_TYPE = "bbox"  # Evaluation type
CONFIDENCE_THRESHOLD = 0.5  # Minimum confidence for detections
N = 10  # Number of images to process

class DetectionEvaluator:
    def __init__(self, coco_gt, iou_threshold=0.5):
        self.coco_gt = coco_gt
        self.iou_threshold = iou_threshold
        self.categories = coco_gt.cats
        self.results = {
            'per_category': defaultdict(lambda: {'true_positives': 0, 'false_positives': 0, 'false_negatives': 0}),
            'timing': []
        }

    def update_timing(self, image_id, preprocessing_time, inference_wallclock_time,
                     inference_cpu_user_time, inference_cpu_system_time):
        """Store timing information for each image"""
        self.results['timing'].append({
            'image_id': image_id,
            'preprocessing_time': preprocessing_time,
            'inference_wallclock_time': inference_wallclock_time,
            'inference_cpu_user_time': inference_cpu_user_time,
            'inference_cpu_system_time': inference_cpu_system_time
        })

    def compute_metrics(self):
        """Compute precision, recall and F1 score for each category and overall"""
        metrics = {}
        total_tp = 0
        total_fp = 0
        total_fn = 0

        # Per-category metrics
        for category_id, values in self.results['per_category'].items():
            tp = values['true_positives']
            fp = values['false_positives']
            fn = values['false_negatives']

            precision = tp / (tp + fp) if (tp + fp) > 0 else 0
            recall = tp / (tp + fn) if (tp + fn) > 0 else 0
            f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

            metrics[category_id] = {
                'precision': precision,
                'recall': recall,
                'f1_score': f1_score
            }

            total_tp += tp
            total_fp += fp
            total_fn += fn

        # Overall metrics
        overall_precision = total_tp / (total_tp + total_fp) if (total_tp + total_fp) > 0 else 0
        overall_recall = total_tp / (total_tp + total_fn) if (total_tp + total_fn) > 0 else 0
        overall_f1 = 2 * (overall_precision * overall_recall) / (overall_precision + overall_recall) if (overall_precision + overall_recall) > 0 else 0

        metrics['overall'] = {
            'precision': overall_precision,
            'recall': overall_recall,
            'f1_score': overall_f1
        }

        # Timing statistics
        if self.results['timing']:
            timing_stats = {
                'preprocessing_time': {
                    'mean': np.mean([t['preprocessing_time'] for t in self.results['timing']]),
                    'std': np.std([t['preprocessing_time'] for t in self.results['timing']])
                },
                'inference_wallclock_time': {
                    'mean': np.mean([t['inference_wallclock_time'] for t in self.results['timing']]),
                    'std': np.std([t['inference_wallclock_time'] for t in self.results['timing']])
                },
                'inference_cpu_user_time': {
                    'mean': np.mean([t['inference_cpu_user_time'] for t in self.results['timing']]),
                    'std': np.std([t['inference_cpu_user_time'] for t in self.results['timing']])
                },
                'inference_cpu_system_time': {
                    'mean': np.mean([t['inference_cpu_system_time'] for t in self.results['timing']]),
                    'std': np.std([t['inference_cpu_system_time'] for t in self.results['timing']])
                }
            }
            metrics['timing'] = timing_stats

        return metrics

def load_model(model_path):
    interpreter = tf.lite.Interpreter(model_path=model_path)
    interpreter.allocate_tensors()
    return interpreter
    
# ... (truncated for brevity - full inference pipeline continues)</pre>
                </div>

                <div class="subsection-break"></div>

                <h6 id="subsection_workspace_commands"><b><u>workspace</u></b></h6>
                <p class="stripped-p">Command options:</p>
                <pre class="command-help">workspace &lt;command&gt;: mandatory argument, workspace command to execute. Can be either
        'sync', 'set' or 'show'.
   &lt;direction&gt;: mandatory for 'sync' command, the direction of file synchronization.
        Can be either 'up' or 'down'.
   -f|--folder &lt;folder name&gt;: can be used with
          'sync' (relative path of a subfolder to synchronize), or with
          'set'  (specifying new folder for the workspace).
   -d|--delete: used with 'sync', enables deletion of extraneous files from the receiving side.</pre>
                <p class="stripped-p">Demonstration of workspace commands.</p>
                <video class="video-screencast" controls>
                    <source src="/screencaptures/mgen.workspace.mp4" type="video/mp4" />
                </video>

                <div class="code-section">
                    <div class="clickable-item">what's going on here?</div>
                    <div>1. The user calls 'workspace show' to display the local workspace currently set
   for the logged-in user.
2. Opens a new terminal tab, switches to the local workspace and creates an empty file
   named 'local_file'.
3. Calls 'workspace sync up' to upload the local file to the user's workspace managed
   by the service.
4. Switches to two other terminal tabs with SSH sessions connected to active containers:
   one on an RPi4 board and another on a Jetson Nano.
   Both containers show 'local_file' in their /workspace mount.
5. The user then creates two additional empty files: '/workspace/rpi4_file' in the RPi4
   container and '/workspace/jnano_file' in the Jetson Nano container.
6. Verifies that all files are visible in the /workspace mount on both containers.
7. Finally, the user runs 'workspace sync down' in the Metriffic CLI to synchronize the
   local workspace with the system workspace. Lists the local directory to confirm that
   all files have been successfully transferred.</div>
                </div>

                <h4 id="section_knownissues">Known issues and limitations</h4>
                <ul style="list-style-type:circle">
                    <li>Endurance of microSD cards?</li>
                    <li>Interactive sessions get stuck pending when no resources are immediately available.</li>
                </ul>

                <h4 id="section_nextsteps">Planned Features</h4>
                <ul style="list-style-type:circle">
                    <li>Users sharing Docker images.</li>
                    <li>Emailing users about running interactive sessions; add an auto-termination policy.</li>
                    <li>Expose CPU usage data to the running container.</li>
                    <li>Add current sensors per board; expose power consumption to the container.</li>
                    <li>Web UI for managing jobs, checking status and reviewing run results.</li>
                </ul>
            </section>
        </main>
    </div>
</body>
</html>